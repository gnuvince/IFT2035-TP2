\documentclass[10pt]{report}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{parskip}

\newcommand{\usage}[1]{\textbf{Utilisation: }\emph{#1}}

\begin{document}

\title{Rapport - Devoir 2}
\date{Novembre 2010}
\author{Vincent Foley-Bourgon (FOLV08078309) \and
  Eric Thivierge (THIE09016601)}

\maketitle

\section{Fonctions}

\subsection{Termes généraux}

Nous utiliserons le mot ``déballer'' pour signifier que nous appelons
une fonction dessinateur avec une fonction de transformation pour
obtenir la liste que le dessinateur contient.  Inversement, nous
utiliserons le mot ``emballer'' pour signifier que nous mettons une
liste dans une expression lambda prenant une fonction de
transformation comme argument.


\subsection{ligne}

\usage{(ligne depart arrivee)}

La fonction \emph{ligne} utilise la fonction utilitaire
\emph{liste-vects} afin de retourner une liste de points (vecteurs)
entre le vecteur de départ et le vecteur d'arrivée.
\emph{liste-vects} est une fonction partiellement terminale qui suit
la spécification donnée dans l'énoncé.

\subsection{parcours-$>$dessinateur}

\usage{(parcours-$>$dessinateur vecteurs)}

\emph{parcours-$>$dessinateur} prend une liste de vecteurs et retourne
un dessinateur qui joint chacun de ces vecteurs par une ligne (telle
que définie dans la sous-section précédente).  Les vecteurs sont pris
deux-à-deux, et les segment du dessinateur résultant sont concaténés
avec le \emph{parcours-$>$dessinateur} du reste des vecteurs.


\subsection{translation}

\usage{(translation dx dy dessinateur)}

La fonction de translation va déballer le dessinateur, appliquer
\emph{translate-segm} à chacun des segments du dessinateur, emballer
le résultat et retourner ce nouveau dessinateur.  La fonction
\emph{translate-segm} ajoute dx et dy aux coordonnées x et y des
vecteurs de départ et d'arrivée d'un segment.


\subsection{rotation}

\usage{(rotation angle dessinateur)}

La fonction de rotation va déballer le dessinateur, appliquer
\emph{rotate-segm} à chacun des segments du dessinateur, emballer le
résultat et retourner ce nouveau dessinateur.  La fonction
\emph{rotate-segm} effectue une rotation horaire de \emph{angle}
degrés aux vecteurs d'un segment.  Une fonction auxiliaire
\emph{degre-$>$radian} effecture la conversion de degrés à radians,
qui sont utilisés par les fonction trigonométrique de Scheme.

\subsection{reduction}

\usage{(reduction factx facty dessinateur)}

La fonction de réduction va déballer le dessinateur, appliquer
\emph{etire-segm} à chacun des segments du dessinateur, emballer le
résultat et retourner ce nouveau dessinateur.  La fonction
\emph{etire-segm} étire un segment par \emph{factx} horizontalement et
par \emph{facty} verticalement.


\section{Impressions de Scheme}

\subsection{Vincent}

\subsubsection{Points positifs de Scheme}

\begin{itemize}
\item Les fonctions anonymes et fermetures permettent de facilement
  paramétriser des fonctions.
\item Les fonctions d'ordre supérieur rendent plus concis la
  manipulation de listes.
\item L'optimisation des appels terminaux permet d'écrire des
  fonctions sans effets de bords, mais dont les performances sont
  équivalentes à celles d'un langage impératif.
\item L'utilisation d'une liste pour stocker les segments permet une
  manipulation facile d'un dessin via les fonctions d'ordre supérieur.
\item Le ``garbage-collector'' permet de manipuler des structures
  complexes sans avoir à se soucier de les libérer nous-mêmes.
\end{itemize}

\subsubsection{Points négatifs de Scheme}
\begin{itemize}
\item L'absence de typage statique permet à des bogues -- qui seraient
  normalement capturés à la compilation -- de ne se manifester qu'à
  l'exécution et seulement si on a la bonne fortune de tester avec les
  bons paramètres.
\item L'utilisation de la paire comme base pour nos types, ainsi que
  l'absence de typage statique, fait que le programmeur a l'entière
  responsabilité de s'assurer que toutes les données sont bien
  formées.
\item L'utilisation de la paire comme base pour les arbres fait qu'il
  n'est pas très naturel d'avoir des arbres contenant des informations
  sur les noeuds.  On doit employer des designs ad hoc, comme par
  exemple mettre l'information dans le \emph{car} de la paire et de
  stocker les pointeurs vers les sous-arbres de gauche et de droite
  dans une pair dans le \emph{cdr}.  Évidemment, la responsabilité de
  respecter ce design est celle du programmeur et le compilateur ne
  peut pas aider.
\item Ce n'est pas très logique d'avoir des fonctions qui retournent
  des valeurs de types différents (ex.: \emph{assoc}).
\item La syntaxe préfixe est un peu lourde dans les calculs
  mathématiques.
\item Dans Emacs, il y a aucune complétion de code, détection
  d'erreurs de syntaxe, d'accès à la documentation, etc.
\item Scheme ne possède pas de ``pattern matching'' (comme dans ML ou
  Haskell) qui permettrait de déconstruire une structure de données.
  Cela demande donc de faire beaucoup d'appels manuels à des fonctions
  comme \emph{car} et \emph{cdr}.
\end{itemize}


\end{document}
