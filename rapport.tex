\documentclass[10pt]{report}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{parskip}

\newcommand{\usage}[1]{\textbf{Utilisation: }\emph{#1}}

\begin{document}

\title{Rapport - Devoir 2}
\date{Novembre 2010}
\author{Vincent Foley-Bourgon (FOLV08078309) \and
  Eric Thivierge (THIE09016601)}

\maketitle

\section{Fonctions}

\subsection{Termes généraux}

Nous utiliserons le mot ``déballer'' pour signifier que nous appelons
une fonction dessinateur avec une fonction de transformation pour
obtenir la liste que le dessinateur contient.  Inversement, nous
utiliserons le mot ``emballer'' pour signifier que nous mettons une
liste dans une expression lambda prenant une fonction de
transformation comme argument.


\subsection{ligne}

\usage{(ligne depart arrivee)}

La fonction \emph{ligne} utilise la fonction utilitaire
\emph{liste-vects} afin de retourner une liste de points (vecteurs)
entre le vecteur de départ et le vecteur d'arrivée.
\emph{liste-vects} est une fonction partiellement terminale qui suit
la spécification donnée dans l'énoncé.

\subsection{parcours-$>$dessinateur}

\usage{(parcours-$>$dessinateur vecteurs)}

\emph{parcours-$>$dessinateur} prend une liste de vecteurs et retourne
un dessinateur qui joint chacun de ces vecteurs par une ligne (telle
que définie dans la sous-section précédente).  Les vecteurs sont pris
deux-à-deux, et les segment du dessinateur résultant sont concaténés
avec le \emph{parcours-$>$dessinateur} du reste des vecteurs.


\subsection{translation}

\usage{(translation dx dy dessinateur)}

La fonction de translation va déballer le dessinateur, appliquer
\emph{translate-segm} à chacun des segments du dessinateur, emballer
le résultat et retourner ce nouveau dessinateur.  La fonction
\emph{translate-segm} ajoute dx et dy aux coordonnées x et y des
vecteurs de départ et d'arrivée d'un segment.


\subsection{rotation}

\usage{(rotation angle dessinateur)}

La fonction de rotation va déballer le dessinateur, appliquer
\emph{rotate-segm} à chacun des segments du dessinateur, emballer le
résultat et retourner ce nouveau dessinateur.  La fonction
\emph{rotate-segm} effectue une rotation horaire de \emph{angle}
degrés aux vecteurs d'un segment.  Une fonction auxiliaire
\emph{degre-$>$radian} effecture la conversion de degrés à radians,
qui sont utilisés par les fonction trigonométrique de Scheme.

\subsection{reduction}

\usage{(reduction factx facty dessinateur)}

La fonction de réduction va déballer le dessinateur, appliquer
\emph{etire-segm} à chacun des segments du dessinateur, emballer le
résultat et retourner ce nouveau dessinateur.  La fonction
\emph{etire-segm} étire un segment par \emph{factx} horizontalement et
par \emph{facty} verticalement.


\section{Impressions de Scheme}

\subsection{Vincent}

\subsubsection{Points positifs de Scheme}

\begin{itemize}
\item Les fonctions anonymes et les fermetures permettent de
  facilement paramétriser des fonctions et permettent des abstractions
  qui seraient impossibles ou inconvenantes en Java.
\item Les fonctions d'ordre supérieur rendent plus concis la
  manipulation de listes.
\item L'optimisation des appels terminaux permet d'écrire des
  fonctions sans effets de bord, mais dont les performances sont
  équivalentes à celles d'un langage impératif.
\item L'utilisation d'une liste pour stocker les segments permet une
  manipulation facile d'un dessin via les fonctions d'ordre supérieur
  (ex.: \emph{map}).
\item Le ``garbage-collector'' permet de manipuler des structures
  complexes sans avoir à se soucier de les libérer nous-mêmes.
\item On peut accomplir beaucoup de choses complexes sans jamais avoir
  à modifier le contenu d'une variable.
\item L'intégration de l'interpréteur \emph{gsi} avec Emacs permet un
  cycle de développement beaucoup plus rapide que ce qui est possible
  avec des langages comme C ou Java.
\item Les fonctions \emph{trace} et \emph{time} sont très utiles pour
  analyser et comparer la performance d'une fonction.
\end{itemize}

\subsubsection{Points négatifs de Scheme}
\begin{itemize}
\item L'absence de typage statique permet à des bogues -- qui seraient
  normalement capturés à la compilation -- de ne se manifester qu'à
  l'exécution et seulement si on a la bonne fortune de tester avec les
  bons (ou mauvais) paramètres.
\item L'utilisation de la paire comme base pour nos types, ainsi que
  l'absence de typage statique, fait que la responsabilité de
  s'assurer que toutes les données sont bien construites repose
  entièrement sur les épaules du programmeur.
\item L'utilisation de la paire comme base pour les arbres leur donne
  un ``goût'' très ad hoc.  On peut par exemple décider de mettre
  l'information propre à un noeud dans le \emph{car} de la paire et de
  mettre les deux branches dans une autre paire qu'on stock dans le
  \emph{cdr} de la paire-noeud.  Évidemment, la responsabilité de
  respecter ce choix de design est celle du programmeur et le
  compilateur ne peut pas aider.
\item Il n'est pas très logique d'avoir des fonctions qui retournent
  des valeurs de types différents (ex.: \emph{assoc}).  Une meilleure
  solution serait d'établir une norme (étant donné qu'on ne encoder
  cette décision dans le système de type et laisser le compilateur
  faire la police) dictant que si une méthode ne retourne ``rien'',
  elle retourne la liste vide, et que si elle retourne une valeur,
  elle la retourne dans une liste. \footnote{Ceci donnerait quelque
    chose de similaire au type \emph{option} de ML.}
\item La syntaxe préfixe est un peu lourde dans les calculs
  mathématiques.
\item Dans Emacs, il y a aucune complétion de code, détection
  d'erreurs de syntaxe ou d'accès à la documentation comme on peut
  trouver dans des IDE pour des langages comme Java.  Peut-être qu'une
  intégration de Gambit avec SLIME pourrait aider?
\item Scheme ne possède pas de ``pattern matching'' (comme dans ML ou
  Haskell) qui permet de ``déconstruire'' une structure de données.
  Cela demande donc de faire beaucoup d'appels manuels à des fonctions
  comme \emph{car} et \emph{cdr} (voir les appels à \emph{caaddr} dans
  \emph{arbre-$>$dessinateur-aux}).
\end{itemize}

\subsubsection{Représentation fonctionnelle}


\end{document}
